# 时间复杂度为O（n²）
## 冒泡排序
```
时间复杂度为O（n²）

开始的交换区间 0~N-1 ， 范围逐步递减
    两两比较，较大的放后面
```

## 选择排序
```
时间复杂度为O（n²）

在 0~N-1上选出最小值，放到位置0
在 1~N-1上选出最小值，放到位置1
依次范围缩小，进行元素位置置换
```

## 插入排序
```
时间复杂度为O（n²）

首先进行位置0和位置1上的元素进行比较，若位置1的元素较小与位置0元素进行交换，位置2的元素与位置1元素比较，若小则交换，位置2的元素再与位置元素进行比较，若小则交换；位置k的元素依次与之前位置的元素进行比较，若小则进行交换
```

# 时间复杂度 ： O（N * logN）
## 归并排序
```
首先让数组中的每一个数成为单位长度为1的有序区间，然后把相邻的长度为1的有序区间进行合并，得到最大长度为2的有序区间，接下来再把相邻有序区间进行合并，依次进行，直到数组中所有数合并成为一个有序区间。
```
## 快速排序
```
随机在数组中选择一个数，小于等于该数的数放在该数位置左边，大于放在右边，接下来对左右两部分分别递归的调用快速排序的过程。

快速排序--划分过程（Partition过程）
    划分过程时间复杂度为 O（N）
```
## 堆排序
```
首先将数组中的数，建设成大小为N的大根堆，堆顶是所有元素中的最大值，把堆顶元素和最后一个元素进行交换，然后将最大值脱离出堆结构，放入数组的最后位置，作为数组的有序部分存储下来；然后将n-1大小的大根堆，进行大根调整，重复之前的过程，依次操作后得到有序数组。
```
## 希尔排序
```
是插入排序改良的排序算法，希尔排序的步长是逐渐调整的，由大到小调整的，以步长为1的情况结束。
希尔排序的关键：步长的选择，步长选择优，时间复杂度低；步长选择劣，时间复杂度趋近于 O（n²）。
```

# 时间复杂度为O(N)的排序算法
*不是基于比较的排序算法*，思想原型来自于**桶排序**，常规的实现 计数排序、基数排序
## 计数排序
```
员工按照身高进行排序
创建有序且个数足够的桶，将数组元素依次放入对应的桶中，当所有员工都存放入桶中后，将有序的桶中的数据依次倒出，得到的数据就是排序后的。
```
## 基数排序
```
设定10个桶分别从0开始标记到9，按照元素个位数值进行入桶操作，元素全部入桶之后，将桶中元素按照桶编号依次倒出，得到新的序列；将新序列按照元素十位数值进行入桶，再倒出，得到新的序列；依次对元素的各个位进行入桶出桶操作，直至到达元素最高位，得到的新的序列就是排序好的结果。
```

# 经典排序算法的空间复杂度
O（1） 插入排序、选择排序、冒泡排序、堆排序、希尔排序<br>
O（logN）~ O(N)  快速排序<br>
O（N） 归并排序<br>
O（M） 计数排序、基数排序（M是桶的数量）<br>

# 经典排序算法稳定性
```
稳定性的概念：
    假定待排序的记录序列中，存在多个具体相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，称这种排序算法是稳定的，否则称为不稳定的。
稳定的排序算法：
    冒泡排序、插入排序、归并排序、计数排序、基数排序、桶排序
不稳定的排序算法：
    选择排序、快速排序、希尔排序、堆排序
```

# 补充说明
```
补充说明一：排序算法无绝对优势
    通常不能随便说哪种排序算法好。这个和要排序的元素相关。例如对人的年龄排序或者身高排序，因为这种数据范围通常比较小，可以考虑采用计数排序。但是对于均匀分布的整数，计数排序就不合适了。除非面试题特别说明，否则认为要排序的数据范围是均匀分布的。
补充说明二：为什么交快速排序
    快速排序之所以交快速排序，并不代表它比堆排序和归并排序优良。在最好情况下，它的渐进复杂度与堆排序和归并排序是相同的。只是快速排序的常量系数比较小而已。
补充说明三：工程上的排序
    1. 工程上的排序是综合排序。
    2. 数组较小时，插入排序。
    3. 数组较大时，快速排序或其他O（N*logN）的排序。
```

# 高频面试题
## 案例一
```
已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离不超过k，并且k相对于数组长度来说很小。请问选择什么方法对其排序比较好。

时间复杂度为 O（N） 的排序算法
    计数排序、基数排序
    不基于比较的排序算法的限制：不适用所有情况

时间复杂度为 O（n²） 的排序算法
    冒泡排序、选择排序
        这两个排序算法与数组原始序列无关
    
    插入排序
        插入排序的过程与原始顺序有关，每个元素移动距离不超过K
        对于本体来说，插入排序 O（N*K）

时间复杂度为 O（N*logN）的排序算法
    快速排序
        与数组原始顺序无关

    归并排序
        与数组原始顺序无关
    
答案：改进后的堆排序
    小根堆，滑块比较
    数组排序完毕，没得到一个数 O（logK）
```
## 案例二
```
判断数组中是否有重复值。必须保证额外空间复杂度为 O（1）。

如果没有空间复杂度限制，用哈希表实现。
    哈希表实现，时间复杂度为 O（N），空间复杂度为 O（N）。

先排序，然后判断
    考察经典排序算法，空间复杂度限制
    O（1）
    冒泡排序 选择排序 插入排序 希尔排序 堆排序
    O（logN） ~ O（N）
    快速排序
    O（N）
    归并排序
    O（M）
    计数排序 基数排序

堆排序，堆排序经典实现使用了递归的方式，堆排序空间复杂度为 O（logN）
    需要改写成非递归实现
```
## 案例三
```
把两个有序数组合并为一个数组。第一个数组空间正好可以容纳两个数组的元素。

从后往前覆盖，当后一个数组的所有元素均比较完成后，数组处理完成。
```
## 案例四
```
荷兰过期问题。只包含0,1,2的整数数组进行排序，要求使用交换、原地排序，而不是利用计数进行排序。

本题主要过程与快排划分过程类似，时间复杂度 O（N），额外空间复杂度 O（1）

```