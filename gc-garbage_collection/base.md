## [为什么需要GC](https://liujiacai.net/blog/2018/06/15/garbage-collection-intro/)

### 堆管理的产生
      块结构语言通过在内存中申请栈帧来实现按需分配的动态策略。在过程被调用时，帧（frame）会被压到栈的最上面，调用结束时弹出。栈分配策略赋予程序员极大的自由度，局部变量在不同的调用过程中具有不同的值，这为递归提供了基础。但是后进先出（Last-In-First-Out, LIFO）的栈限制了栈帧的生命周期不能超过其调用者，而且由于每个栈帧是固定大小，所以一个过程的返回值也必须在编译期确定。所以诞生了新的内存管理策略——堆（heap）管理。
### GC需求的诞生
      堆分配运行程序员按任意顺序分配/释放程序所需的数据结构——动态分配的数据结构可以脱离其调用者生命周期的限制，这种便利性带来的问题是垃圾对象的回收管理。

### GC管理不当常见问题
      C/C++/Pascal 把这个任务交给了程序员，但事实证明这非常容易出错，野指针（wild pointer）、悬挂指针（dangling pointer）是比较典型的错误。

### GC不适应场景
      GC 并不适应于 socket/file handler 等资源的回收，究其原因是 GC 的不确定性。
      有些 GC 系统在清理如端口等资源的引用时，回去将其释放（这称为finalization），但这同样具有不确定性，所以我们并不能依赖这些机制，需要显式对其回收（一般调用 close/destroy 方法）。

### 内存适合于GC回收
      重要原因：独占性。操作系统给每个运行的程序分配的内存是相互独立的，所以可以完全由 GC 来决定什么时刻去对其进行释放，只需保证在报 OutOfMemory 异常之前就可以了。


## GC的定义
      GC 是一种自动管理内存的技术，用来回收（释放） heap 中不再使用的对象。

      GC 的对象是内存，但内存在一运行的程序中通常会划分为多个区域，其中最常见的是栈（stack） 与堆（heap）。栈的空间一般较小，在一个函数调用时用以分配其内部变量，在函数调用结束时自动回收，这里并不涉及到 GC；而堆的空间一般较大，可以在多个函数间共享数据，程序可根据需要进行动态申请，GC 主要是工作在这个区域。
### GC的过程
    两个阶段
      1. 区分活对象（live object）与垃圾对象（garbage）
      2. 回收垃圾对象的内存，使得程序可以重复使用这些内存

## GC常用策略
### 追踪（Tracing）
      目前使用范围最广的技术，一般我们提到 GC 都是指这类。
      从某些被称为 root 的对象开始，不断追踪可以被引用到的对象，这些对象被称为可到达的（reachable），其他剩余的对象就被称为 garbage，并且会被释放。
#### 实现追踪机制的系统
      JVM/.NET/OCaml

#### 对象的可到达性
      可到达的对象主要包含下面两类情况：
        1. root 对象，这包括全局对象、调用栈（call stack）上的对象（包括内部变量与参数）
        2. 从 root 对象开始，间接引用的对象
#### 可到达性的局限
      采用可到达行来区分一个对象是否为 garbage 有一定的局限性，因为程序中真正使用一个对象时距其创建可能需要很久。

#### 强引用&弱引用
      强引用 (Strong  Reference) 就是我们常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还活着，垃圾回收不回收这种对象。
      弱引用，比软引用拥有更短的生命周期，在垃圾回收线程扫码所管辖的内存区域的过程中，一大发现了只具有弱引用的对象，不管当前内存空间是否足够，都会回收它的内存，由于垃圾回收器是一个优先级，因此不一定很快发现那些只有弱引用的对象。
      软引用，是一种相对强引用弱化一些的引用，只有当 JVM 认为内存不足时，才会试图回收软引用指向的对象。JVM 会确保在排除 OutOfMemoryError 之前，清理软引用指向的对象，软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时，清理掉，这样就保证了使用缓存的同时，不会耗尽内存。
      虚引用，形同虚设 ，虚引用不会决定对象的生命周期，如果一个对象仅持有虚引用，其实就和没有任何引用一样。在任何时候都可能被垃圾回收器回收。虚引用和软引用的一个区别是，虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。
[*四种引用对比*](https://cloud.tencent.com/developer/article/1632634)

|引用类型|被垃圾回收时间|用途|生存时间|
|:--:|:--:|:--:|:--:|
|强引用|从来不会|对象的一般状态|JVM停止运动时终止|
|弱引用|正常垃圾回收时|对象缓存|垃圾回收后终止|
|软引用|当内存不足时|对象缓存|内存不足时终止|
|虚引用|正常垃圾回收时|跟踪对象的垃圾回收|垃圾回收后终止|

#### 使用弱引用可以解决的问题
      循环引用
      在 Map 中，如果允许 key 为弱引用，那么 GC 就可以回收用不到对象，而不会因为 Map 中的引用让其一直留在内存中，适用于做缓存
#### 基本算法 mark-and-sweep
      该算法主要包括两步，
      1. mark，从 root 开始进行树遍历，每个访问的对象标注为「使用中」
      2. sweep，扫描整个内存区域，对于标注为「使用中」的对象去掉该标志，对于没有该标注的对象直接回收掉

    该算法的缺点有：
      1. 在进行 GC 期间，整个系统会被挂起（暂停，Stop-the-world），所以在一些实现中，会采用各种措施来减少这个暂停时间
      2. heap 容易出现碎片。实现中一般会进行 move 或 compact。（需要说明一点，所有 heap 回收机制都会这个问题）
      3. 在 GC 工作一段时间后，heap 中连续地址上存在 age 不同的对象，这非常不利于引用的本地化（locality of reference）
      4. 回收时间与 heap 大小成正比
#### 引用计数（Reference counting）
    引用计数类 GC 会记录每个对象的引用次数，当引用次数为0时，就会被回收，这类 GC 实现起来较为简单。采用这类 GC 的主流语言有：Python/PHP/Perl/TCL/Objective-C。 与追踪类 GC 相比，有以下两处优势：
    1. 可以保证对象引用为0时立马得到清理，无不确定行
    2. 大多数操作具有增量特性（incremental），GC 可与应用交替运行，不需要暂停应用即可完成回收功能
    3. 可以用来优化运行时性能。比如函数式编程中所推崇的「不可变数据结构」的更新就能收益：运行时知道某个对象的引用为1，这时对这个对象进行修改，类似 str <- str+"a"，那么这个修改就可以在本地进行，而不必进行额外的 copy
    
    除了上面介绍的优势，引用计数具有以下几处劣势：
    1. 无法解决循环引用。CPython 使用独特的环检测算法规避3，后面文章再分析该算法；此外也可以用弱引用的方式解决
    2. 实现一个高效率的引用计数 GC 比较困难。主要包括下面两方面
        （1）space overhead，每个对象需要额外的空间来存储其引用次数，在追踪类 GC 中，用以标注对象是否在使用中的flag 位一般放在引用变量里面
        （2）speed overhead，在增加/减少对象的引用时，需要修改引用次数。这对于栈上的赋值（on-stack assignment，比如函数调用是的参数、函数内部变量等）影响是非常大的，因为之前只需要简单修改寄存器里面的值，现在需要一个原子操作（这涉及到加锁，会浪费几百个 CPU cycles）4
    3. 减少一个对象的引用计数时，会级联减少其引用对象的计数，这就可能造成同时删除过多的对象。在实现中一般会把要回收的对象放入一队列，当程序申请大小为 N 的内存时，从这个队列取出总体积不小于 N 的一个或多个对象将其回收。
#### 逃逸分析（Escape_analysis）
      通过逃逸分析，来将在 heap 中分配的对象分配到 stack 中。如果一个对象的使用只出现在某一函数内（即没有 escape），那么这个对象就完全可以分配在该函数的 stack 中，减少 GC 的工作量。

## 总结
      「追踪」与「引用计数」这两类 GC 各有千秋，真正的工业级实现一般是这两者的结合，不同的语言有所偏重而已。
      总体来说，追踪类 GC 是效率最高的算法，其变种也比较多，后面的文章也会重点讲述此类 GC，这里面有趣的内容非常多，比如：semispace（用以提高 sweep 的速度与减少内存碎片）、Cheney’s algorithm / Baker’s Algorithm（这两算法都是对 semispace 的优化）、generational GC（减少 GC 作用范围）、incremental/concurrent GC（减少 stop-the-world 时间）。